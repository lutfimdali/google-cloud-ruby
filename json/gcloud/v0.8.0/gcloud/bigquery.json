{"id":"gcloud/bigquery","name":"Bigquery","title":["Gcloud","Bigquery"],"description":"<h1 id=\"google-cloud-bigquery\">Google Cloud BigQuery</h1>\n\n<p>Google Cloud BigQuery enables super-fast, SQL-like queries against massive\ndatasets, using the processing power of Google’s infrastructure. To learn\nmore, read <a href=\"https://cloud.google.com/bigquery/what-is-bigquery\">What is\nBigQuery?</a>.</p>\n\n<p>Gcloud’s goal is to provide an API that is familiar and comfortable to\nRubyists. Authentication is handled by <a data-custom-type=\"gcloud\" data-method=\"bigquery-instance\">Gcloud#bigquery</a>. You can provide\nthe project and credential information to connect to the BigQuery service,\nor if you are running on Google Compute Engine this configuration is taken\ncare of for you. You can read more about the options for connecting in the\n<a href=\"https://googlecloudplatform.github.io/gcloud-ruby/#/docs/guides/authentication\">Authentication\nGuide</a>.</p>\n\n<p>To help you get started quickly, the first few examples below use a public\ndataset provided by Google. As soon as you have <a href=\"https://cloud.google.com/bigquery/sign-up\">signed\nup</a> to use BigQuery, and provided\nthat you stay in the free tier for queries, you should be able to run these\nfirst examples without the need to set up billing or to load data (although\nwe’ll show you how to do that too.)</p>\n\n<h2 id=\"listing-datasets-and-tables\">Listing Datasets and Tables</h2>\n\n<p>A BigQuery project holds datasets, which in turn hold tables. Assuming that\nyou have not yet created datasets or tables in your own project, let’s\nconnect to Google’s <code>publicdata</code> project, and see what you find.</p>\n\n<pre><code class=\"language-ruby\">require \"gcloud\"\n\ngcloud = Gcloud.new \"publicdata\"\nbigquery = gcloud.bigquery\n\nbigquery.datasets.count #=&gt; 1\nbigquery.datasets.first.dataset_id #=&gt; \"samples\"\n\ndataset = bigquery.datasets.first\ntables = dataset.tables\n\ntables.count #=&gt; 7\ntables.map &amp;:table_id #=&gt; [..., \"shakespeare\", \"trigrams\", \"wikipedia\"]\n</code></pre>\n\n<p>In addition listing all datasets and tables in the project, you can also\nretrieve individual datasets and tables by ID. Let’s look at the structure\nof the <code>shakespeare</code> table, which contains an entry for every word in every\nplay written by Shakespeare.</p>\n\n<pre><code class=\"language-ruby\">require \"gcloud\"\n\ngcloud = Gcloud.new \"publicdata\"\nbigquery = gcloud.bigquery\n\ndataset = bigquery.dataset \"samples\"\ntable = dataset.table \"shakespeare\"\n\ntable.headers #=&gt; [\"word\", \"word_count\", \"corpus\", \"corpus_date\"]\ntable.rows_count #=&gt; 164656\n</code></pre>\n\n<p>Now that you know the column names for the Shakespeare table, you can write\nand run a query.</p>\n\n<h2 id=\"running-queries\">Running queries</h2>\n\n<p>BigQuery offers both synchronous and asynchronous methods, as explained in\n<a href=\"https://cloud.google.com/bigquery/querying-data\">Querying Data</a>.</p>\n\n<h3 id=\"synchronous-queries\">Synchronous queries</h3>\n\n<p>Let’s start with the simpler synchronous approach. Notice that this time you\nare connecting using your own default project. This is necessary for running\na query, since queries need to be able to create tables to hold results.</p>\n\n<pre><code class=\"language-ruby\">require \"gcloud\"\n\ngcloud = Gcloud.new\nbigquery = gcloud.bigquery\n\nsql = \"SELECT TOP(word, 50) as word, COUNT(*) as count \" +\n      \"FROM publicdata:samples.shakespeare\"\ndata = bigquery.query sql\n\ndata.count #=&gt; 50\ndata.next? #=&gt; false\ndata.first #=&gt; {\"word\"=&gt;\"you\", \"count\"=&gt;42}\n</code></pre>\n\n<p>The <code>TOP</code> function shown above is just one of a variety of functions\noffered by BigQuery. See the <a href=\"https://cloud.google.com/bigquery/query-reference\">Query\nReference</a> for a full\nlisting.</p>\n\n<h3 id=\"asynchronous-queries\">Asynchronous queries</h3>\n\n<p>Because you probably should not block for most BigQuery operations,\nincluding querying as well as importing, exporting, and copying data, the\nBigQuery API enables you to manage longer-running jobs. In the asynchronous\napproach to running a query, an instance of <a data-custom-type=\"gcloud/bigquery/queryjob\">Gcloud::Bigquery::QueryJob</a> is\nreturned, rather than an instance of <a data-custom-type=\"gcloud/bigquery/querydata\">Gcloud::Bigquery::QueryData</a>.</p>\n\n<pre><code class=\"language-ruby\">require \"gcloud\"\n\ngcloud = Gcloud.new\nbigquery = gcloud.bigquery\n\nsql = \"SELECT TOP(word, 50) as word, COUNT(*) as count \" +\n      \"FROM publicdata:samples.shakespeare\"\njob = bigquery.query_job sql\n\njob.wait_until_done!\nif !job.failed?\n  job.query_results.each do |row|\n    puts row[\"word\"]\n  end\nend\n</code></pre>\n\n<p>Once you have determined that the job is done and has not failed, you can\nobtain an instance of <a data-custom-type=\"gcloud/bigquery/querydata\">Gcloud::Bigquery::QueryData</a> by calling\n<a data-custom-type=\"gcloud/bigquery/queryjob\" data-method=\"query_results-instance\">Gcloud::Bigquery::QueryJob#query_results</a>. The query results for both of\nthe above examples are stored in temporary tables with a lifetime of about\n24 hours. See the final example below for a demonstration of how to store\nquery results in a permanent table.</p>\n\n<h2 id=\"creating-datasets-and-tables\">Creating Datasets and Tables</h2>\n\n<p>The first thing you need to do in a new BigQuery project is to create a\n<a data-custom-type=\"gcloud/bigquery/dataset\">Gcloud::Bigquery::Dataset</a>. Datasets hold tables and control access to\nthem.</p>\n\n<pre><code class=\"language-ruby\">require \"gcloud/bigquery\"\n\ngcloud = Gcloud.new\nbigquery = gcloud.bigquery\ndataset = bigquery.create_dataset \"my_dataset\"\n</code></pre>\n\n<p>Now that you have a dataset, you can use it to create a table. Every table\nis defined by a schema that may contain nested and repeated fields. The\nexample below shows a schema with a repeated record field named\n<code>cities_lived</code>. (For more information about nested and repeated fields, see\n<a href=\"https://cloud.google.com/bigquery/preparing-data-for-bigquery\">Preparing Data for\nBigQuery</a>.)</p>\n\n<pre><code class=\"language-ruby\">require \"gcloud\"\n\ngcloud = Gcloud.new\nbigquery = gcloud.bigquery\ndataset = bigquery.dataset \"my_dataset\"\n\ntable = dataset.create_table \"people\" do |schema|\n  schema.string \"first_name\", mode: :required\n  schema.record \"cities_lived\", mode: :repeated do |nested_schema|\n    nested_schema.string \"place\", mode: :required\n    nested_schema.integer \"number_of_years\", mode: :required\n  end\nend\n</code></pre>\n\n<p>Because of the repeated field in this schema, we cannot use the CSV format\nto load data into the table.</p>\n\n<h2 id=\"loading-records\">Loading records</h2>\n\n<p>In addition to CSV, data can be imported from files that are formatted as\n<a href=\"http://jsonlines.org/\">Newline-delimited JSON</a> or\n<a href=\"http://avro.apache.org/\">Avro</a>, or from a Google Cloud Datastore backup. It\ncan also be “streamed” into BigQuery.</p>\n\n<p>To follow along with these examples, you will need to set up billing on the\n<a href=\"https://console.developers.google.com\">Google Developers Console</a>.</p>\n\n<h3 id=\"streaming-records\">Streaming records</h3>\n\n<p>For situations in which you want new data to be available for querying as\nsoon as possible, inserting individual records directly from your Ruby\napplication is a great approach.</p>\n\n<pre><code class=\"language-ruby\">require \"gcloud\"\n\ngcloud = Gcloud.new\nbigquery = gcloud.bigquery\ndataset = bigquery.dataset \"my_dataset\"\ntable = dataset.table \"people\"\n\nrows = [\n    {\n        \"first_name\" =&gt; \"Anna\",\n        \"cities_lived\" =&gt; [\n            {\n                \"place\" =&gt; \"Stockholm\",\n                \"number_of_years\" =&gt; 2\n            }\n        ]\n    },\n    {\n        \"first_name\" =&gt; \"Bob\",\n        \"cities_lived\" =&gt; [\n            {\n                \"place\" =&gt; \"Seattle\",\n                \"number_of_years\" =&gt; 5\n            },\n            {\n                \"place\" =&gt; \"Austin\",\n                \"number_of_years\" =&gt; 6\n            }\n        ]\n    }\n]\ntable.insert rows\n</code></pre>\n\n<p>There are some trade-offs involved with streaming, so be sure to read the\ndiscussion of data consistency in <a href=\"https://cloud.google.com/bigquery/streaming-data-into-bigquery\">Streaming Data Into\nBigQuery</a>.</p>\n\n<h3 id=\"uploading-a-file\">Uploading a file</h3>\n\n<p>To follow along with this example, please download the\n<a href=\"http://www.ssa.gov/OACT/babynames/names.zip\">names.zip</a> archive from the\nU.S. Social Security Administration. Inside the archive you will find over\n100 files containing baby name records since the year 1880. A PDF file also\ncontained in the archive specifies the schema used below.</p>\n\n<pre><code class=\"language-ruby\">require \"gcloud\"\n\ngcloud = Gcloud.new\nbigquery = gcloud.bigquery\ndataset = bigquery.dataset \"my_dataset\"\ntable = dataset.create_table \"baby_names\" do |schema|\n  schema.string \"name\", mode: :required\n  schema.string \"sex\", mode: :required\n  schema.integer \"number\", mode: :required\nend\n\nfile = File.open \"names/yob2014.txt\"\nload_job = table.load file, format: \"csv\"\n</code></pre>\n\n<p>Because the names data, although formatted as CSV, is distributed in files\nwith a <code>.txt</code> extension, this example explicitly passes the <code>format</code> option\nin order to demonstrate how to handle such situations. Because CSV is the\ndefault format for load operations, the option is not actually necessary.\nFor JSON saved with a <code>.txt</code> extension, however, it would be.</p>\n\n<h3 id=\"a-note-about-large-uploads\">A note about large uploads</h3>\n\n<p>You may encounter a Broken pipe (<code>Errno::EPIPE</code>) error when attempting to\nupload large files. To avoid this problem, add the\n<a href=\"https://rubygems.org/gems/httpclient\">httpclient</a> gem to your project, and\nthe line (or lines) of configuration shown below. These lines must execute\nafter you require gcloud but before you make your first gcloud connection.\nThe first statement configures <a href=\"https://rubygems.org/gems/faraday\">Faraday</a>\nto use httpclient. The second statement, which should only be added if you\nare using a version of Faraday at or above 0.9.2, is a workaround for <a href=\"https://github.com/GoogleCloudPlatform/gcloud-ruby/issues/367\">this\ngzip issue</a>.</p>\n\n<pre><code class=\"language-ruby\">require \"gcloud\"\n\n# Use httpclient to avoid broken pipe errors with large uploads\nFaraday.default_adapter = :httpclient\n\n# Only add the following statement if using Faraday &gt;= 0.9.2\n# Override gzip middleware with no-op for httpclient\nFaraday::Response.register_middleware :gzip =&gt;\n                                        Faraday::Response::Middleware\n\ngcloud = Gcloud.new\nbigquery = gcloud.bigquery\n</code></pre>\n\n<h2 id=\"exporting-query-results-to-google-cloud-storage\">Exporting query results to Google Cloud Storage</h2>\n\n<p>The example below shows how to pass the <code>table</code> option with a query in order\nto store results in a permanent table. It also shows how to export the\nresult data to a Google Cloud Storage file. In order to follow along, you\nwill need to enable the Google Cloud Storage API in addition to setting up\nbilling.</p>\n\n<pre><code class=\"language-ruby\">require \"gcloud\"\n\ngcloud = Gcloud.new\nbigquery = gcloud.bigquery\ndataset = bigquery.dataset \"my_dataset\"\nsource_table = dataset.table \"baby_names\"\nresult_table = dataset.create_table \"baby_names_results\"\n\nsql = \"SELECT name, number as count \" +\n      \"FROM baby_names \" +\n      \"WHERE name CONTAINS 'Sam' \" +\n      \"ORDER BY count DESC\"\nquery_job = dataset.query_job sql, table: result_table\n\nquery_job.wait_until_done!\n\nif !query_job.failed?\n\n  storage = gcloud.storage\n  bucket_id = \"bigquery-exports-#{SecureRandom.uuid}\"\n  bucket = storage.create_bucket bucket_id\n  extract_url = \"gs://#{bucket.id}/baby-names-sam.csv\"\n\n  extract_job = result_table.extract extract_url\n\n  extract_job.wait_until_done!\n\n  # Download to local filesystem\n  bucket.files.first.download \"baby-names-sam.csv\"\n\nend\n</code></pre>\n\n<p>If a table you wish to export contains a large amount of data, you can pass\na wildcard URI to export to multiple files (for sharding), or an array of\nURIs (for partitioning), or both. See <a href=\"https://cloud.google.com/bigquery/exporting-data-from-bigquery\">Exporting Data From\nBigQuery</a>\nfor details.</p>","source":"lib/gcloud/bigquery.rb#L389","resources":[],"examples":[],"methods":[]}